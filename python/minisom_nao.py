from numpy import genfromtxt, zeros, product
from parameters import param

import plot_som as ps
import sys
import os

from minisom import MiniSom

def get_path():
	"""
	Path to .dat file generated by NAO's babbling is given by a user in 
	terminal. If valid, return. 
	"""
	nrarg = len(sys.argv)

	if nrarg<2:
		raise Exception('Missing data path')

	path = str(sys.argv[1])

	if not os.path.exists(path):
		raise Exception('Path doesn\'t exist')

	return path

def read_data(path):
	"""
	Return babbling coordinates for hands and joints.
		nrpts - take each nrpts-th coordinate for training
	"""
	
	hands = param['hands']
	joints = param['joints']
		
	data = {
		'hands': genfromtxt(path, skiprows=3, usecols=hands),
		'joints': genfromtxt(path, skiprows=3, usecols=joints)
		}

	return data 

def train_som(data):
	
	som = MiniSom(
		param['nr_rows'],
		param['nr_cols'], 
		data.shape[1], 
		data, 
		sigma=param['sigma'], 
		learning_rate=param['learning_rate'], 
		norm='minmax')
		
	#som.random_weights_init() # choose initial nodes from data points
	som.train_random(param['nr_epochs']) # random training
	
	return som

def hebbian_learning(som1, som2, data):
	s1, s2 = som1.weights.shape, som2.weights.shape
	hebb = zeros((param['nr_rows'], param['nr_cols'], param['nr_rows'], param['nr_cols']))
	
	for dp1, dp2 in zip(data['hands'], data['joints'])[:10]:
		act1 = som1.activate(dp1)
		act2 = som2.activate(dp2)
		
		idx1 = divmod(act1.argmax(), param['nr_rows'])[::-1]
		idx2 = divmod(act2.argmax(), param['nr_rows'])[::-1]
		
		hebb[idx1[0], idx1[1], idx2[0], idx2[1]] = param['eta'] * act1[idx1[0], idx1[1]] * act2[idx2]
		
	return hebb

# debug
def plot(som_hands, som_joints):
	wi_0, w_0 = som_hands.get_weights()	
	wi_1, w_1 = som_joints.get_weights()

	ps.plot_3d(final_som=w_0, data=som_hands.data[::50], init_som=wi_0, nr_nodes=param['n_to_plot'], title='SOM Hands')
	ps.plot_3d(final_som=w_1, data=som_joints.data[::50], init_som=wi_1, nr_nodes=param['n_to_plot'], title='SOM Joints')

	ps.show()

if __name__=="__main__":
	path = get_path()

	# get the coordinates learned during random motor babbling 
	data = read_data(path)

	# train self-organizing maps
	som_hands = train_som(data['hands'])
	som_joints = train_som(data['joints'])

	#plot(som_hands, som_joints)
	
	# hebbian learning between maps
	hebb_weights = hebbian_learning(som_hands, som_joints, data)

	# print the strongest connections
